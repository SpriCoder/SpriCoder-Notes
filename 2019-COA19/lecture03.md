**Integer, Floating-point and Decimal Representation**
---
<!-- TOC -->

- [1. 数据的二进制表示](#1-数据的二进制表示)
    - [1.1. 补码](#11-补码)
    - [1.2. 数据移动](#12-数据移动)
        - [1.2.1. 补码的具体计算](#121-补码的具体计算)
- [2. 浮点数操作](#2-浮点数操作)
    - [2.1. 浮点数](#21-浮点数)
    - [2.2. IEEE754标准](#22-ieee754标准)
        - [2.2.1. IEEE754标准要求](#221-ieee754标准要求)
        - [2.2.2. 计数法约定](#222-计数法约定)
        - [2.2.3. 表示范围](#223-表示范围)
        - [2.2.4. 问题解决:表示靠近0的比较小的数字](#224-问题解决表示靠近0的比较小的数字)
        - [2.2.5. 问题解决:特别大的数](#225-问题解决特别大的数)
        - [2.2.6. 总共能表示的数字的数量](#226-总共能表示的数字的数量)
    - [2.3. 如何调整后这个模型](#23-如何调整后这个模型)
    - [2.4. 扩展版——64位](#24-扩展版64位)
    - [2.5. 例子](#25-例子)
- [3. 其他的要求存在的问题](#3-其他的要求存在的问题)
    - [3.1. NBCD(W8421)](#31-nbcdw8421)

<!-- /TOC -->


# 1. 数据的二进制表示

1. 为表示出多个数值，必须对多个位进行组合
    + 如果有k位，最多能区分2<sup>k</sup>个不同的值。
2. 整数类型:
    1. 无符号整数:0 - (2<sup>k</sup>-1)
    2. 有符号整数:( - 2<sup>k-1</sup> - 2<sup>k-1</sup>-1)
        1. 原码、反码、补码
        2. 原码和反码在进行加法运算时都会造成不必要的硬件需求，于是出现了补码
        3. 二进制补码转换
        4. 二进制-十进制转换
3. 常见问题:
    1. 只能确定最多表示多少个数，而不能确定具体表示啥。

## 1.1. 补码
1. 可以解决正负数相加减的问题。
    + 但是不会影响其加减的运算能力。
2. 补码是原码的"取反加一"。
3. 为什么会存在补码?
    1. 比如用钟表表示(-6)-5，可以看成就是把大的数字减去12，得到的即可。
    2. 接下来类比，我们找到0,按照顺序来排位我们可以知道(1000····0是最最小的)，接下来1开头的所有的数字的无符号值，减去2<sup>k</sup>得到的就是实际的负值。
    3. 那么接下来如何计算呢？
4. x<sub>补码</sub>+(-x)<sub>补码</sub> = 2<sup>k</sup>
5. 证明为什么是取反加一:(-x)<sub>补码</sub> = ((2<sup>k</sup>-1) - x<sub>补码</sub>) + 1
    + 对应取反加一

## 1.2. 数据移动
1. 逻辑左移:右端补充0
2. 算术左移:右端补充0
3. 逻辑右移:左侧补充0
4. 算术右移:左侧补充符号位

### 1.2.1. 补码的具体计算
1. 过程:
    1. 数值=x<sub>k-1</sub>*2<sup>k-1</sup> + ··· + x<sub>1</sub>*2<sup>1</sup>+ x<sub>0</sub>*2<sup>0</sup> - x<sub>k-1</sub>*2<sup>k</sup>(最大值，类比为12)
    2. = -x<sub>k-1</sub>*2<sup>k-1</sup> + x<sub>k-2</sub>*2<sup>k-2</sup> + ··· + x<sub>1</sub>*2<sup>1</sup> + x<sub>0</sub>*2<sup>0</sup>
2. 用数轴来解释，所以是在数轴上平移到右边，所以是取模的操作。

![](https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt3/cpt3-1.png)

# 2. 浮点数操作

![](https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt3/cpt3-2.png)

1. 为什么我们需要表示浮点数?
    + 除了整数以外，我们还有很多浮点数的操作。
2. 规定小数点的位置，小数点的位置可以来区分不同的浮点数，那么我们为什么不使用这样的方法？(定点数)
    + 因为这样的话，**精度每提高一位，窗口缩小一倍**，浮点数表示的范围比较大。
    + (-2<sup>k-1</sup>-(2<sup>k-1</sup>-1))*2<sup>-1</sup>
3. 为什么浮点数可以表示一个更大的范围？
    + 牺牲了比较大的部分的精度。

## 2.1. 浮点数

![](https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt3/cpt3-3.png)

1. 符号只需要一位。
2. 基数是确定的，自己约定好的。

## 2.2. IEEE754标准

![](https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt3/cpt3-4.png)

1. 固定小数点位数:定下x的小数点位置。

### 2.2.1. IEEE754标准要求

![](https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt3/cpt3-01.jpg)

![](https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt3/cpt3-02.jpg)

### 2.2.2. 计数法约定
![](https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt3/cpt3-5.png)

1. 理论上我们可以表示出来所有的数字，总能移到1出现的位置。
2. 偏移量为设定为127，基数设定为2。


### 2.2.3. 表示范围
![](https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt3/cpt3-6.png)

1. 符号位:正负
1. 指数范围:-127-128
2. 数值范围:1-(2-2<sup>-23</sup>)(1.111...1)
3. 能表示的数字总数一定为什么表示的范围增大了？
    + 稀疏了，在原来的里面变化是均匀的
    + 每次E变大的时候，会造成在小的时候的间隔是2<sup>-23-127</sup>，而在大的时候的间隔是2<sup>-23+128</sup>
4. 为什么这样子表示有意义的？
    + 对于一个很大的数，只要能保证一个大致的量即可，比较小的量无关紧要。
    + 而对很小的数就有意义。
5. 所以在2<sup>-1</sup>-1.111...1中有2<sup>23</sup>份的每一份，1.111...1和2<sup>0</sup>这个距离是相同的。
    + 越靠近0越密
6. 问题:存在无法表示的位置，-2<sup>-127</sup>和2<sup>-127</sup>无法进行表示。无法表示0。
    1. 从总体上来讲，这个问题比较小。
    2. 但是从相邻的2<sup>-126</sup>中可以看到这是很大的。
7. 问题解决:想要表示这些数据，我们就需要牺牲一部分表示别的的数字来表示中间的部分。

### 2.2.4. 问题解决:表示靠近0的比较小的数字

![](https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt3/cpt3-7.png)

1. 我们使用特殊的规定来表示这样的数字。
2. 基数E为0，但是值S不全为0，这部分拿出来，重新布局到-2<sup>-126</sup>-2<sup>-126</sup>这部分中去，一共有2<sup>24</sup>-2个元素。
    + 这时候我们只要在前面加上0.bbb...b即可,也就是0.bbb...b*2<sup>-126</sup>
    + 这时候我们就需要乘以2<sup>-126</sup>
3. 基数E不为0，S也不为0，是1.bbb...b*2<sup>E-127</sup>

### 2.2.5. 问题解决:特别大的数
1. 正无穷，负无穷:基数255

### 2.2.6. 总共能表示的数字的数量
1. 2<sup>32</sup>
2. -2+1(0)
3. -2+2(NaN)
4. -(2<sup>23</sup>-1)*2+1(无穷大)
5. 总体上比2<sup>32</sup>要小。

## 2.3. 如何调整后这个模型

![](https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt3/cpt3-8.png)

1. B大一点:会影响精度
    + 里面会变密，外面会变稀疏
    + 外面会快很多。
2. 把指数位变大:棍子会减少

## 2.4. 扩展版——64位

![](https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt3/cpt3-9.png)

## 2.5. 例子
![](https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt3/cpt3-10.png)

# 3. 其他的要求存在的问题

![](https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt3/cpt3-11.png)

1. 浮点数在表示比较大的数字的时候，精度比较低。
2. 定点数的问题:范围会减少。
3. 问题:我们需要比较大的数字，也许要比较高的精度。

## 3.1. NBCD(W8421)

![](https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt3/cpt3-12.png)

1. 符号位置:
    1. 1100是正号。或者0
    2. 1101是负号。或者1
2. 好处和优点:
    1. 十进制和BNCD的转换很自然很准确
    2. 也支持小数，有几位也都可以